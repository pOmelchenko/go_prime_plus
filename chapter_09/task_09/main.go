package main

import (
	"fmt"
	"os"
)

// Упражнение по программированию 9.8
//
// В главе 6 была показана функция <code>power()</code> (листинг 6.20), которая возвращает результат возведения
// числа <code>double</code> в положительную целую степень. Усовершенствуйте эту функцию, чтобы она корректно возводила
// числа в отрицательные степени. Кроме того, добавьте в функцию возможность оценки как 0 результата возведения 0 в
// любую степень кроме 0 и оценки как 1 результата возведения любого числа в степень 0. (Функция должна сообщать, что
// результат возведения 0 в степень 0 не определен и что она использует значение 1.)
// Примените цикл. Протестируйте функцию в какой-нибудь программе.
func main() {
	var (
		x, xpow float32
		exp     int
		err     error
	)

	fmt.Println("Введите число и целую степень, в которую число будет возведено.")
	fmt.Println("Для завершения программы введите q")

	_, err = fmt.Scanf("%f%d", &x, &exp)

	if err != nil {
		os.Exit(0)
	}

	for {

		xpow = power(x, exp)
		fmt.Printf("%.3g в степени %d равно %.5g\n", x, exp, xpow)
		fmt.Println("Введите следующую пару чисел или q для завершения.")

		_, err = fmt.Scanf("%f%d", &x, &exp)
		if err != nil {
			break
		}
	}
	fmt.Println("Надеемся, что вы оценили это упражнение -- до свиданья!")
}

func power(n float32, p int) float32 {
	var result float32 = 1

	if p != 0 && n == 0 {
		return 0
	}

	if p == 0 && n != 0 {
		return 1
	}

	if n == 0 && p == 0 {
		fmt.Println("!! Результат не определен")
		return 1
	}

	if p > 0 {
		result *= power(n, p-1)
	}

	if p < 0 {
		p *= -1
		result *= power(n, p-1)
		result = 1 / result
	}

	return result
}
